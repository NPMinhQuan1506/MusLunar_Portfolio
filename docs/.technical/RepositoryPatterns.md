# MusLunar Portfolio - Repository Patterns

## Principles
- Follow Clean Architecture: repositories expose interfaces consumed by usecases, implemented with sqlc.
- No business logic in repositories; only data persistence and mapping.
- Accept `context.Context` for every method; support cancellation/timeouts.
- Return domain models; map transport/DTO shapes in delivery layer.

## Interface Example
```go
type ProjectRepository interface {
    List(ctx context.Context, filter ProjectFilter, page Pagination) ([]Project, PageMeta, error)
    GetBySlug(ctx context.Context, slug string) (*Project, error)
    CreateContact(ctx context.Context, msg ContactMessage) (string, error)
}
```

## Implementation Notes (sqlc)
- Use prepared queries generated by sqlc; keep SQL in `db/queries/*.sql`.
- Map DB nullables to `sql.Null*` or pointers; convert to domain types in repo.
- Transactions: orchestrated by usecase when multiple writes required.
- Pagination: always `LIMIT/OFFSET` with deterministic ordering (`published_at DESC`).

## Testing
- Unit: mock repositories to isolate usecases.
- Integration: run against local/test Postgres (or Supabase) with migrations; seed minimal fixtures.
- Avoid hitting production services in tests.

## Error Handling
- Wrap lower-level errors with context; return sentinel errors for not-found/unique violations.
- Do not log inside repos unless debugging; logging occurs at delivery boundary.

## When to Split Repos
- Split by aggregate (project, timeline, contact, shop).
- Keep interfaces small; if an interface grows beyond one aggregate, refactor.
